// SPDX-License-Identifier: MIT
pragma solidity >=0.7.0 <0.9.0;

contract Winner {
    // this contract sets the winner when the balance reaches 7 ether and then
    // makes it possible for the winner to withdraw funds
    address winner;
    uint balance;

    function pay() external payable {
        require(msg.value == 1 ether, "You need to send 1 ether");

        // if (address(this).balance == 7 ether) {
        //     winner = msg.sender;
        // }

        // to fix the explot, I will use the variable balance and increase it's value
        balance += 1 ether;
        if (balance == 7 ether) {
            winner = msg.sender;
        }
    }

    function withdraw() public {
        require(msg.sender == winner, "You are not the winner");

        // multiple ways of sending the funds;
        (bool sent, ) = payable(winner).call{value: address(this).balance}("");
        // (bool sent, ) = payable(winner).call{value: balance}("");
        // (bool sent, ) = payable(winner).call{value: 7 ether}("");
        require(sent, "Payment failed");
    }
}


contract Thief {
    receive() external payable { 
        // as soon as I receive any funds, put the address of this smart contract here and make the other unsusable????
        // cica daca am address(this).balance, cumva pot sa mess with it folosind selfdestruct, by sending funds, no matterhat
        // That is why I need state variables
        // selfdestruct()
    }
}